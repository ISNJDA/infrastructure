# Introduction

Un fichier stocke des informations sur un support physique (disque dur, clé USB, CD, DVD, carte mémoire SD...). Pour fonctionner, un ordinateur a en général besoin d'accéder à un grand nombre de fichiers.

Si vous avez déjà ouvert **l'explorateur de fichiers** sous Windows ou Linux, vous êtes sûrement déjà familier avec le concept de **dossier** et de **fichier**. Un **fichier** contient des données, un **dossier** rassemble plusieurs fichiers, ou contient des sous-dossiers.

## Naviguer dans un système de fichiers par ligne de commande

En ouvrant une ligne de commande (terminal Linux), vous pouvez utiliser :
* la commande **cd** pour vous déplacer entre les dossiers.
* la commande **more** pour consulter le contenu d'un fichier texte.
* la commande **ls** pour afficher la liste des fichiers contenus dans le dossier courant.
* la commande **pwd** pour afficher le chemin du dossier courant.

Vous pouvez vous exercer en tapant les commandes suivantes :
```shell
cd /
ls
cd ~
pwd
ls
cd ..
pwd
```

# Les Fichiers

Il est important de comprendre comment un système de fichier est organisé et comment accéder aux fichiers en Python.
Ouvrir un fichier consiste à le charger dans la mémoire vive (RAM) de l'ordinateur (c'est une mémoire volatile : elle s'efface quand on éteint l'ordinateur).
Enregistrer un fichier consiste à l'écrire sur un support physique de stockage (l'information est alors conservée de manière permanente).

Il existe deux types de fichiers :

* Les fichiers textes : l'information est stockée sous forme de caractères lisibles par un éditeur de texte (principalement des lettres et des chiffres).
* Les fichiers binaires : l'information est stockée en binaire (une suite d'octets dont la valeur est comprise entre 0x00 et 0xFF).

## Ecriture dans un fichier
L'écriture dans un fichier se fait avec la fonction open() en mode écriture :

```python
NomFichier = 'test.txt'
# création et ouverture du fichier test.txt en mode write 'w' (écriture)
# si le fichier test.txt existe déjà, il est écrasé
Fichier = open(NomFichier,'w')      # instanciation de l'objet Fichier de la classe file
# écriture dans le fichier avec la méthode write()
Fichier.write('Bonjour à tous !')
# fermeture du fichier avec la méthode close()
Fichier.close()
```
Le fichier test.txt est créé dans le dossier courant; sous Windows c'est normalement le dossier C:/PythonXX, mais on peut aussi choisir un emplacement quelconque en spécifiant le chemin absolu, par exemple :
```python
NomFichier = 'F:/Mon dossier/test.txt'
```
Vous pouvez vérifier son contenu en l'ouvrant avec un éditeur de texte (ou même avec un logiciel de traitement de texte).

## Lecture dans un fichier

### Lecture en mode texte

La lecture dans un fichier texte se fait avec la fonction open() en mode ... lecture :
```python
# ouverture du fichier test.txt en mode read 'r' (lecture en mode texte)
Fichier = open('test.txt','r')      # instanciation de l'objet Fichier de la classe file
# lecture dans le fichier avec la méthode read()
chaine = Fichier.read()
# affichage du contenu du fichier
print('Contenu du fichier :\n' + chaine)
# fermeture du fichier avec la méthode close()
Fichier.close() 
```
### Lecture en mode binaire

En mode texte, un fichier est lu caractère par caractère.
En mode binaire, un fichier est lu octet par octet : c'est un peu différent !

Par exemple, si on veut la taille d'un fichier, il faut utiliser la lecture en mode binaire 'rb' (read binary) :

```python
# ouverture du fichier test.txt en mode read binary 'rb' (lecture en mode binaire)
Fichier = open('test.txt','rb')
data = Fichier.read()
# affichage de la taille du fichier
print('Taille du fichier :',len(data),'octets')
# affichage du contenu (en hexadécimal)
import binascii
print(binascii.hexlify(data))
# fermeture du fichier avec la méthode close()
Fichier.close() 
```

Resultat : 
```
Taille du fichier : 69 octets
b'426f6e6a6f757220e020746f757320210d0a556e65206465757869e86d65206c69676e652e0d0a61626309414243093132330d0a3132362e38350d0a3141610d0a620d0a63'
La taille du fichier est 69 octets avec le codage cp1252 (sous Windows) et 65 octets avec le codage UTF-8 (sous Linux).
```

Avec la lecture en mode texte 'r', on peut obtenir 63 octets avec le codage *cp1252* (sous Windows) et 65 octets avec le codage *UTF-8* (sous Linux) !

# Navigation entre fichiers et dossiers

Un ordinateur stocke les données sur un système de fichiers - Ce système de fichiers est organisé en arborescence de dossiers.
Un fichier (FILE) contient des informations (sons, vidéo, texte) — et un dossier (FOLDER) — qui contient d’autres dossiers ou des fichiers.

Un chemin (PATH) est une suite de dossiers qui représente un endroit unique sur le système de fichiers, exemples :
```
/home/julie/Musique/son.mp3
C:\Python31\python.exe
```
Ces deux chemins sont différents, car Windows et Linux utilisent un caractère séparateur différent pour séparer les noms de dossiers ( / pour Linux et \ pour Windows ).
Heureusement, Python utilise indifféremment les deux caractères ce qui permet à nos programmes de fonctionner partout sans changer le code.

Il existe deux types de chemins :

* les chemins absolus : ces derniers partent de la racine du système (/ sous Unix, C: sous Windows), et indiquent le chemin détaillé pour arriver à l’endroit indiqué (les deux exemples donnés plus haut sont des chemins absolus) ;

* les chemins relatifs : le chemin est donné à partir d’un dossier spécifique, qui est considéré, en quelque sorte, comme une nouvelle racine. Par exemple
```
Musique/son.mp3
```
est un chemin relatif et n’a de sens que si l’on précise le dossier courant, en l'occurrence **/home/julie**.

Il est très important de faire la différence entre ces deux types de chemins. Généralement, nous préférerons utiliser des chemins absolus dans nos programmes, afin d’être certain de l’endroit où l’on travaille.

Il est facile de distinguer les chemins relatifs et absolus : un chemin absolu commencera toujours par un slash sous Unix, ou par une lettre de lecteur suivie de deux points sous Windows.

Dans un système de fichiers, il est existe toujours deux dossiers qui permettent de se déplacer dans l'arborescence :

* **.** (point) désigne le dossier courant.
* **..** (double point) désigne le dossier parent.

Pour fixer les idées, imaginons que je me trouve dans le dossier **/home/julie/Musique**. Alors "**..**" sera équivalent au dossier **/home/julie** et "**.**" désignera **/home/julie/Musique**.


## Manipulation des noms chemins
En Python, les chemins sont tout simplement des objets de type chaîne de caractères. Il est donc possible de les manipuler avec les opérations classiques des chaînes, bien que cela ne soit pas toujours conseillé (par exemple, pour coller deux chemins, il vaut mieux utiliser join() que l’opérateur +). Toutes les fonctions de base pour manipuler les noms de chemin se trouvent dans le module os.path.

```python
os.path.abspath(path) # -> Retourne le chemin absolu du chemin relatif path donné en argument. Il permet aussi de simplifier les éventuelles répétitions de séparateurs.

os.path.realpath(path) #  -> Retourne le chemin path en remplaçant les liens symboliques par les vrais chemins, et en éliminant les séparateurs excédentaires.

os.path.split(path) # -> Sépare path en deux parties à l’endroit du dernier séparateur : la deuxième partie contient le fichier ou le dossier final, et la première contient tout le reste (c’est à dire le chemin pour y accéder).

os.path.basename(path) # -> Retourne le dernier élément du chemin. Cela revient à appeler :func:~os.path.split et à récupérer le deuxième élément du tuple.

os.path.dirname(path) # -> Retourne le chemin pour accéder au dernier élément. Cela revient à appeler :func:~os.path.split et à récupérer le premier élément du tuple.

os.path.expanduser(path) # -> Si path est ~ ou ~user, retourne le chemin permettant d’accéder au dossier personnel de l’utilisateur.

os.path.join(path1[, path2[, ...]]) # -> Permet de concaténer plusieurs chemins.
```

:warning: Toutes ces fonctions retournent une valeur même si le chemin donné en argument n’existe pas. Il peut donc être nécessaire de tester leur existence avec les fonctions que nous verrons plus bas.

Voici quelques exemples de manipulations de noms de chemin, en utilisant l’interpréteur de script python sur un Raspberry Pi (utilisateur **pi**).

```
$ cd ~
$ mkdir Musique
$ python
>>> import os
>>>  path = '/home/pi/Musique'
>>>  os.path.split(path) 
('/home/pi', 'Musique')
>>>  os.path.join(path, 'Classique')
'/home/pi/Musique/Classique'
>>>  os.path.expanduser('~')
'/home/pi'
>>>  os.path.abspath('.')
'/home/pi/Musique'
>>>  os.path.realpath('/mnt//dev/')
'/mnt/dev'
>>>  os.path.dirname(path)
'/home/pi'
>>> os.path.basename(path)
'Musique'
```

:warning: Observez le code suivant :
```shell
>>> import os
>>> path = '/home/pi/Musique/'
>>> os.path.split(path) # 
('/home/pi/Musique', '')
```

Il faut donc faire attention à ne pas laisser de séparateur à la fin. On peut utiliser **realpath()** ou **abspath()** avant tout appel à une autre fonction de chemins, afin de s’assurer que les chemins sont au bon format :
```shell
>>> import os
>>> path = '/home/pi/Musique/'
>>> os.path.split(os.path.abspath(path))
('/home/pi', 'Musique')
```

## Lister les fichiers et les dossiers
Le module **os** contient une fonction qui permet de lister simplement les éléments d’un dossier.

```python
os.listdir(path) # -> Liste tous les dossiers et fichiers qui se trouvent dans path. Les dossiers . et .. sont automatiquement retirés.
```

Toutefois, pour un usage plus compliqué, on préfera le module **glob**, qui contient deux fonctions uniquement. Les fonctions de ce module permettent de lister tous les fichiers dont les noms correspondent au motif donné en argument. Le motif peut contenir certains caractères spéciaux :
* * remplace n’importe quelle séquence de caractères.
* ? remplace un caractère.
* [] symbolise n’importe quel caractère indiqué dans les crochets.

```python
glob.glob(pathname) # -> Liste tous les dossiers et fichiers dont le motif du nom correspond à pathname.
glob.iglob(pathname) # -> Fonctionne de même que glob() mais retourne un itérateur. Cette fonction est donc préférable.
```

L’exemple qui suit est tiré de la documentation Python. Il suppose que vous ayez un dossier qui contient au moins les fichiers suivants : 1.gif, 2.txt et card.gif.

```shell
$ python
> import glob
> glob.glob('./[0-9].*')
['./1.gif', './2.txt']
> glob.glob('*.gif')
['1.gif', 'card.gif']
> glob.glob('?.gif')
['1.gif']
```

# Tests sur les fichiers et les dossiers
Les tests de base sur les dossiers et fichiers se font tous à partir de fonctions du module **os.path**.

```python
os.path.exists(path)  # -> Permet de vérifier si path est un chemin qui existe bien.
os.path.isabs(path) # -> Teste si path est un chemin absolu.
os.path.isdir(path) # -> Teste si path pointe vers un dossier.
os.path.isfile(path) # ->Teste si path pointe vers un fichier.
```

Voici quelques exemples :
```shell
$ python
>>> import os
>>> path = '/home/pi'
>>> os.path.exists(path )
True
>>> os.path.isabs(path)
True
>>> os.path.isfile(path)
False
```


Contenu adapté de : 
* http://fsincere.free.fr/isn/python/cours_python_fichier.php
* http://fr.wikibooks.org/wiki/Apprendre_%C3%A0_programmer_avec_Python/Les_fichiers
